package com.chapter7parallel;import java.util.concurrent.RecursiveTask;/** * Created by wangwenchao02 on 2017/8/22. */public class ForkJoinSumCalculator extends RecursiveTask<Long> {    private final long[] numbers;    private final int start;    private final int end;    private static final long THRESHOLD = 10_000;       // 最小阈值, 小于该值则不再细分    public ForkJoinSumCalculator(long[] numbers) {        this(numbers, 0, numbers.length);    }    public ForkJoinSumCalculator(long[] numbers, int start, int end) {        this.numbers = numbers;        this.start = start;        this.end = end;    }    @Override    protected Long compute() {        int len = end - start;        if (len <= THRESHOLD) {            return computeSequentially();        }        ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(numbers, start, start + len/2);        leftTask.fork();        ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(numbers, start + len/2, end);        long rightResult = rightTask.compute(); // right 不用 fork, 因为可以重用当前线程, 避免一次线程创建的开销        long leftResult = leftTask.join();      // join 会阻塞调用方, 直至任务完成. join 用法类似尾递归原理        return leftResult + rightResult;    }    private Long computeSequentially() {        long sum = 0;        for (int i = start; i < end; i++) {            sum += numbers[i];        }        return sum;    }}