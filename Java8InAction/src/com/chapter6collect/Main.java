package com.chapter6collect;import static java.util.stream.Collectors.collectingAndThen;import static java.util.stream.Collectors.groupingBy;import static java.util.stream.Collectors.maxBy;import static java.util.stream.Collectors.partitioningBy;import static java.util.stream.Collectors.summingInt;import java.util.Arrays;import java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Optional;/** * Created by wangwenchao02 on 2017/8/21. */public class Main {    private Trader t1 = new Trader("Raoul", "Cambridge");    private Trader t2 = new Trader("Mario", "Milan");    private Trader t3 = new Trader("Alan", "Cambridge");    private Trader t4 = new Trader("Brain", "Cambridge");    private List<Transaction> transactions = Arrays.asList(            new Transaction(t1, 2012, 1000),            new Transaction(t4, 2011, 300),            new Transaction(t1, 2011, 400),            new Transaction(t2, 2012, 710),            new Transaction(t2, 2012, 700),            new Transaction(t3, 2012, 950)    );    public static void main(String[] args) {        Main main = new Main();        int valSum = main.transactions.stream().collect(summingInt(Transaction::getValue));        Map<ValueLevel, List<Transaction>> map = main.groupTransaction(main.transactions);        System.out.println(map);        Map<Integer, Map<ValueLevel, List<Transaction>>> map2 = main.groupMultiTransaction(main.transactions);        System.out.println(map2);        Map<Integer, Map<ValueLevel, Transaction>> map21 = main.groupMultiTransactionAndThen(main.transactions);        Map<Boolean, Map<ValueLevel, List<Transaction>>> map3 = main.partitionTransaction(main.transactions);        System.out.println(map3);    }    private static ValueLevel getTransactionValueType(Transaction t) {        if (t.getValue() < 333) {            return ValueLevel.LOW;        } else if (t.getValue() < 666) {            return ValueLevel.MEDIUM;        } else {            return ValueLevel.HIGH;        }    }    Map<ValueLevel, List<Transaction>> groupTransaction(List<Transaction> transactions) {        return transactions.stream()                .collect(groupingBy(Main::getTransactionValueType));    }    Map<Integer, Map<ValueLevel, List<Transaction>>> groupMultiTransaction(List<Transaction> transactions) {        return transactions.stream()                .collect(groupingBy(Transaction::getYear,                        groupingBy(Main::getTransactionValueType)));    }    Map<Integer, Map<ValueLevel, Integer>> groupMultiTransactionSum(List<Transaction> transactions) {        return transactions.stream()                .collect(groupingBy(Transaction::getYear,                        groupingBy(Main::getTransactionValueType, summingInt(Transaction::getValue))));    }    Map<Integer, Map<ValueLevel, Transaction>> groupMultiTransactionAndThen(List<Transaction> transactions) {        return transactions.stream()                .collect(groupingBy(Transaction::getYear,                        groupingBy(Main::getTransactionValueType,                                collectingAndThen(maxBy(Comparator.comparingInt(Transaction::getValue)),                                        Optional::get)                        )));    }    Map<Integer, Map<ValueLevel, Optional<Transaction>>> groupMultiTransactionAndThen2(List<Transaction> transactions) {        return transactions.stream()                .collect(groupingBy(Transaction::getYear,                        groupingBy(Main::getTransactionValueType,                                maxBy(Comparator.comparingInt(Transaction::getValue)))                ));    }    Map<Boolean, Map<ValueLevel, List<Transaction>>> partitionTransaction(List<Transaction> transactions) {        return transactions.stream().collect(                partitioningBy(t -> t.getYear() == 2012,                        groupingBy(Main::getTransactionValueType)));    }}